"""
Retrieval module for APPLUS3.
GENERATED BY MULTI-IA CONSENSUS (GPT-4o + Claude + DeepSeek)
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional
from knowledge_graph import KnowledgeGraph, Node, Edge, NodeType, EdgeType

@dataclass
class RetrievalResult:
    nodes: List[Node]
    context_text: str
    relevance: float

class ContextRetriever:
    def __init__(self, kg: KnowledgeGraph) -> None:
        self.kg = kg

    def get_context_for_node(self, node_id: str) -> RetrievalResult:
        """Retrieve context for a given node including the node itself and its neighbors."""
        target_node = self.kg.get_node(node_id)
        if not target_node:
            return RetrievalResult(nodes=[], context_text="", relevance=0.0)

        neighbor_nodes = self.kg.get_neighbors(node_id)
        all_nodes = [target_node] + neighbor_nodes

        context_text = self._generate_context_text(target_node, neighbor_nodes)
        relevance = self._calculate_relevance(target_node, neighbor_nodes)

        return RetrievalResult(
            nodes=all_nodes,
            context_text=context_text,
            relevance=relevance
        )

    def _generate_context_text(self, target_node: Node, neighbors: List[Node]) -> str:
        """Generate a textual representation of the context."""
        lines = [f"Target Node: {target_node.id} ({target_node.node_type.value})"]
        lines.append(f"Content: {target_node.content[:200]}...")

        if neighbors:
            lines.append("\nConnected Nodes:")
            for neighbor in neighbors:
                lines.append(f"  - {neighbor.id} ({neighbor.node_type.value}): {neighbor.content[:100]}...")
        else:
            lines.append("\nNo connected nodes found.")

        return "\n".join(lines)

    def _calculate_relevance(self, target_node: Node, neighbors: List[Node]) -> float:
        """Calculate a relevance score for the retrieved context."""
        base_relevance = 1.0
        neighbor_bonus = min(len(neighbors) * 0.1, 0.5)
        content_bonus = 0.2 if len(target_node.content) > 50 else 0.0

        return min(base_relevance + neighbor_bonus + content_bonus, 1.0)

    def build_prompt_context(self, result: RetrievalResult) -> str:
        """Build a formatted prompt context from retrieval results."""
        if not result.nodes:
            return "No context available."

        prompt_lines = ["=== CODE CONTEXT ==="]

        for node in result.nodes:
            prompt_lines.append(f"\n--- {node.id} ({node.node_type.value}) ---")
            prompt_lines.append(f"Metadata: {node.metadata}")
            prompt_lines.append(f"Content:\n{node.content}")

        prompt_lines.append(f"\n=== END CONTEXT (Relevance: {result.relevance:.2f}) ===")

        return "\n".join(prompt_lines)
