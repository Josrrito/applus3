"""
Knowledge Graph module for APPLUS3.
GENERATED BY MULTI-IA CONSENSUS (GPT-4o + Claude + DeepSeek)
"""

from __future__ import annotations
from enum import Enum
from dataclasses import dataclass
from typing import List, Dict, Optional
import json

class NodeType(Enum):
    FUNCTION = "FUNCTION"
    CLASS = "CLASS"
    MODULE = "MODULE"
    PATTERN = "PATTERN"

class EdgeType(Enum):
    DEPENDS_ON = "DEPENDS_ON"
    IMPLEMENTS = "IMPLEMENTS"
    USES = "USES"

@dataclass
class Node:
    id: str
    node_type: NodeType
    content: str
    metadata: Dict[str, str]

@dataclass
class Edge:
    source_id: str
    target_id: str
    edge_type: EdgeType
    weight: float = 1.0

class KnowledgeGraph:
    def __init__(self) -> None:
        self.nodes: Dict[str, Node] = {}
        self.edges: List[Edge] = []

    def add_node(self, node: Node) -> None:
        """Add a node to the knowledge graph."""
        self.nodes[node.id] = node

    def add_edge(self, edge: Edge) -> None:
        """Add an edge to the knowledge graph."""
        if edge.source_id in self.nodes and edge.target_id in self.nodes:
            self.edges.append(edge)
        else:
            raise ValueError("Both source and target nodes must exist in the graph.")

    def get_node(self, node_id: str) -> Optional[Node]:
        """Retrieve a node by its ID."""
        return self.nodes.get(node_id)

    def get_neighbors(self, node_id: str) -> List[Node]:
        """Get all neighboring nodes connected by edges from the given node."""
        neighbors = []
        for edge in self.edges:
            if edge.source_id == node_id:
                neighbor = self.nodes.get(edge.target_id)
                if neighbor:
                    neighbors.append(neighbor)
        return neighbors

    def save_to_json(self, path: str) -> None:
        """Save the knowledge graph to a JSON file."""
        data = {
            "nodes": [node.__dict__ for node in self.nodes.values()],
            "edges": [edge.__dict__ for edge in self.edges]
        }
        with open(path, 'w') as f:
            json.dump(data, f, indent=4)

    def load_from_json(self, path: str) -> None:
        """Load the knowledge graph from a JSON file."""
        with open(path, 'r') as f:
            data = json.load(f)
            self.nodes = {node_data['id']: Node(**node_data) for node_data in data['nodes']}
            self.edges = [Edge(**edge_data) for edge_data in data['edges']]
