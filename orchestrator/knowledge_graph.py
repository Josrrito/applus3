"""
APPLUS3 Knowledge Graph Module
Generated by Multi-IA Consensus (GPT-4o + Claude + DeepSeek)

Implements a knowledge graph as single source of truth for project structure,
dependencies, and patterns. Provides JSON-backed persistence with CRUD operations.
"""

import json
import threading
from dataclasses import dataclass, asdict, field
from typing import Dict, List, Optional, Any
from pathlib import Path
from enum import Enum


class NodeType(str, Enum):
    """Valid node types in the knowledge graph."""
    FUNCTION = "Function"
    CLASS = "Class"
    MODULE = "Module"
    PATTERN = "Pattern"
    DEPENDENCY = "Dependency"


class EdgeType(str, Enum):
    """Valid edge types in the knowledge graph."""
    DEPENDS_ON = "DEPENDS_ON"
    IMPLEMENTS = "IMPLEMENTS"
    USES_PATTERN = "USES_PATTERN"
    EXPORTS = "EXPORTS"


@dataclass
class Node:
    """Represents a node in the knowledge graph."""
    id: str
    type: str
    name: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    file_path: str = ""

    def __post_init__(self):
        """Validate node data after initialization."""
        if not self.id:
            raise ValueError("Node ID cannot be empty")
        if not self.name:
            raise ValueError("Node name cannot be empty")
        if self.metadata is None:
            self.metadata = {}

    def to_dict(self) -> Dict[str, Any]:
        """Convert node to dictionary representation."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Node':
        """Create node from dictionary representation."""
        return cls(**data)


@dataclass
class Edge:
    """Represents an edge in the knowledge graph."""
    source_id: str
    target_id: str
    edge_type: str
    weight: float = 1.0

    def __post_init__(self):
        """Validate edge data after initialization."""
        if not self.source_id:
            raise ValueError("Source ID cannot be empty")
        if not self.target_id:
            raise ValueError("Target ID cannot be empty")
        if self.weight < 0:
            raise ValueError("Edge weight must be non-negative")

    def to_dict(self) -> Dict[str, Any]:
        """Convert edge to dictionary representation."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Edge':
        """Create edge from dictionary representation."""
        return cls(**data)


class KnowledgeGraph:
    """
    Thread-safe knowledge graph with JSON persistence.
    Serves as the Single Source of Truth for APPLUS3 project.
    """

    def __init__(self, storage_path: str = "knowledge_graph.json"):
        """
        Initialize the knowledge graph.

        Args:
            storage_path: Path to JSON file for persistence
        """
        self.storage_path = Path(storage_path)
        self._nodes: Dict[str, Node] = {}
        self._edges: List[Edge] = []
        self._lock = threading.Lock()

        # Create storage directory if it doesn't exist
        self.storage_path.parent.mkdir(parents=True, exist_ok=True)

        # Load existing data if file exists
        if self.storage_path.exists():
            self.load()

    def add_node(self, node: Node) -> None:
        """
        Add or update a node in the knowledge graph.

        Args:
            node: Node instance to add
        """
        with self._lock:
            self._nodes[node.id] = node

    def add_edge(self, edge: Edge) -> None:
        """
        Add an edge to the knowledge graph.

        Args:
            edge: Edge instance to add
        """
        with self._lock:
            # Check for duplicate edges
            for existing_edge in self._edges:
                if (existing_edge.source_id == edge.source_id and
                    existing_edge.target_id == edge.target_id and
                    existing_edge.edge_type == edge.edge_type):
                    existing_edge.weight = edge.weight
                    return
            self._edges.append(edge)

    def get_node(self, node_id: str) -> Optional[Node]:
        """
        Retrieve a node by its ID.

        Args:
            node_id: ID of the node to retrieve

        Returns:
            Node instance if found, None otherwise
        """
        with self._lock:
            return self._nodes.get(node_id)

    def get_dependencies(self, node_id: str) -> List[Node]:
        """
        Get all nodes that the specified node depends on.

        Args:
            node_id: ID of the node to get dependencies for

        Returns:
            List of nodes that the specified node depends on
        """
        with self._lock:
            dependencies = []
            for edge in self._edges:
                if edge.source_id == node_id and edge.edge_type == EdgeType.DEPENDS_ON.value:
                    target_node = self._nodes.get(edge.target_id)
                    if target_node:
                        dependencies.append(target_node)
            return dependencies

    def get_dependents(self, node_id: str) -> List[Node]:
        """
        Get all nodes that depend on the specified node.

        Args:
            node_id: ID of the node to get dependents for

        Returns:
            List of nodes that depend on the specified node
        """
        with self._lock:
            dependents = []
            for edge in self._edges:
                if edge.target_id == node_id and edge.edge_type == EdgeType.DEPENDS_ON.value:
                    source_node = self._nodes.get(edge.source_id)
                    if source_node:
                        dependents.append(source_node)
            return dependents

    def query_by_type(self, node_type: str) -> List[Node]:
        """
        Query nodes by their type.

        Args:
            node_type: Type of nodes to retrieve

        Returns:
            List of nodes matching the specified type
        """
        with self._lock:
            return [node for node in self._nodes.values() if node.type == node_type]

    def get_all_nodes(self) -> List[Node]:
        """Get all nodes in the graph."""
        with self._lock:
            return list(self._nodes.values())

    def get_all_edges(self) -> List[Edge]:
        """Get all edges in the graph."""
        with self._lock:
            return list(self._edges)

    def remove_node(self, node_id: str) -> bool:
        """
        Remove a node and all associated edges.

        Args:
            node_id: ID of the node to remove

        Returns:
            True if node was removed, False if not found
        """
        with self._lock:
            if node_id not in self._nodes:
                return False

            del self._nodes[node_id]
            self._edges = [
                e for e in self._edges
                if e.source_id != node_id and e.target_id != node_id
            ]
            return True

    def save(self) -> None:
        """Save the knowledge graph to JSON file."""
        with self._lock:
            data = self.to_dict()
            with open(self.storage_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

    def load(self) -> None:
        """Load the knowledge graph from JSON file."""
        with self._lock:
            if not self.storage_path.exists():
                return

            with open(self.storage_path, 'r', encoding='utf-8') as f:
                data = json.load(f)

            self._nodes = {
                node_data['id']: Node.from_dict(node_data)
                for node_data in data.get('nodes', [])
            }
            self._edges = [
                Edge.from_dict(edge_data)
                for edge_data in data.get('edges', [])
            ]

    def to_dict(self) -> dict:
        """Convert knowledge graph to dictionary representation."""
        return {
            'nodes': [node.to_dict() for node in self._nodes.values()],
            'edges': [edge.to_dict() for edge in self._edges]
        }

    def clear(self) -> None:
        """Clear all nodes and edges from the graph."""
        with self._lock:
            self._nodes.clear()
            self._edges.clear()

    def stats(self) -> Dict[str, int]:
        """Get statistics about the knowledge graph."""
        with self._lock:
            return {
                'total_nodes': len(self._nodes),
                'total_edges': len(self._edges),
                'node_types': len(set(n.type for n in self._nodes.values())),
                'edge_types': len(set(e.edge_type for e in self._edges))
            }
