"""
Orchestrator module for APPLUS3.
GENERATED BY MULTI-IA CONSENSUS (GPT-4o + Claude + DeepSeek)
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Any, Optional
import json
import uuid

from .knowledge_graph import KnowledgeGraph, Node, Edge, NodeType, EdgeType
from .retrieval import ContextRetriever, RetrievalResult
from .anchored_review import AnchoredReviewer, ReviewScore


@dataclass
class PipelineResult:
    pipeline_id: str
    idea: str
    m0_result: Dict[str, Any]
    m1_result: Dict[str, Any]
    m2_result: Dict[str, Any]
    validation_scores: List[ReviewScore]
    status: str


class Orchestrator:
    """
    Main orchestrator for APPLUS3 pipeline that sequences M0 analysis, M1 codegen, and M2 deployment.
    Integrates knowledge graph, context retrieval, and anchored review components.
    """

    def __init__(self, kg_path: Optional[str] = None) -> None:
        """
        Initialize the orchestrator with all necessary components.

        Args:
            kg_path: Optional path to load existing knowledge graph from JSON
        """
        self.knowledge_graph = KnowledgeGraph()
        if kg_path:
            self.knowledge_graph.load_from_json(kg_path)

        self.context_retriever = ContextRetriever(self.knowledge_graph)
        self.anchored_reviewer = AnchoredReviewer(self.knowledge_graph, self.context_retriever)

    def run_pipeline(self, idea: str) -> PipelineResult:
        """
        Execute the complete APPLUS3 pipeline: M0 -> M1 -> M2.

        Args:
            idea: The input idea/requirement to process

        Returns:
            PipelineResult containing pipeline results and metadata
        """
        pipeline_id = str(uuid.uuid4())

        try:
            # M0: Analysis phase
            m0_result = self._run_m0(idea)

            # M1: Code generation phase
            m1_result = self._run_m1(m0_result["primary_node_id"])

            # Validate generated code
            validation_scores = self.validate_output(
                m1_result["generated_code"],
                m0_result["primary_node_id"]
            )

            # M2: Deployment phase
            m2_result = self._run_m2(m1_result["generated_code"])

            status = "completed"

        except Exception as e:
            m0_result = {"error": str(e)}
            m1_result = {"error": str(e)}
            m2_result = {"error": str(e)}
            validation_scores = []
            status = "failed"

        return PipelineResult(
            pipeline_id=pipeline_id,
            idea=idea,
            m0_result=m0_result,
            m1_result=m1_result,
            m2_result=m2_result,
            validation_scores=validation_scores,
            status=status
        )

    def _run_m0(self, idea: str) -> Dict[str, Any]:
        """
        M0: Analysis phase - decompose idea and populate knowledge graph.

        Args:
            idea: The input idea to analyze

        Returns:
            Dictionary with analysis results and created node IDs
        """
        primary_node_id = str(uuid.uuid4())
        primary_node = Node(
            id=primary_node_id,
            node_type=NodeType.MODULE,
            content=idea,
            metadata={"phase": "m0", "is_primary": "true"}
        )
        self.knowledge_graph.add_node(primary_node)

        # Analyze idea and create component nodes
        components = self._analyze_components(idea)
        component_node_ids = []

        for component in components:
            comp_node_id = str(uuid.uuid4())
            comp_node = Node(
                id=comp_node_id,
                node_type=NodeType.FUNCTION,
                content=component,
                metadata={"phase": "m0", "parent": primary_node_id}
            )
            self.knowledge_graph.add_node(comp_node)
            component_node_ids.append(comp_node_id)

            edge = Edge(
                source_id=primary_node_id,
                target_id=comp_node_id,
                edge_type=EdgeType.DEPENDS_ON
            )
            self.knowledge_graph.add_edge(edge)

        return {
            "primary_node_id": primary_node_id,
            "component_nodes": component_node_ids,
            "analysis_summary": f"Decomposed into {len(component_node_ids)} components"
        }

    def _run_m1(self, node_id: str) -> Dict[str, Any]:
        """
        M1: Code generation phase using context from retriever.

        Args:
            node_id: ID of the node to generate code for

        Returns:
            Dictionary with generated code and metadata
        """
        retrieval_result = self.context_retriever.get_context_for_node(node_id)
        prompt_context = self.context_retriever.build_prompt_context(retrieval_result)

        generated_code = self._generate_code(prompt_context, node_id)

        code_node_id = str(uuid.uuid4())
        code_node = Node(
            id=code_node_id,
            node_type=NodeType.FUNCTION,
            content=generated_code,
            metadata={"phase": "m1", "source_node": node_id}
        )
        self.knowledge_graph.add_node(code_node)

        edge = Edge(
            source_id=node_id,
            target_id=code_node_id,
            edge_type=EdgeType.IMPLEMENTS
        )
        self.knowledge_graph.add_edge(edge)

        return {
            "code_node_id": code_node_id,
            "generated_code": generated_code,
            "context_used": prompt_context
        }

    def _run_m2(self, code: str) -> Dict[str, Any]:
        """
        M2: Deployment/configuration phase.

        Args:
            code: Generated code to deploy

        Returns:
            Dictionary with deployment results
        """
        deployment_config = self._create_deployment_config(code)

        return {
            "deployment_config": deployment_config,
            "deployment_status": "configured",
            "deployed_at": "local_environment"
        }

    def validate_output(self, code: str, node_id: str) -> List[ReviewScore]:
        """
        Validate generated code using anchored reviewer.

        Args:
            code: Code to validate
            node_id: Associated node ID for context

        Returns:
            List of review scores
        """
        return self.anchored_reviewer.review_code(code, node_id)

    def _analyze_components(self, idea: str) -> List[str]:
        """Analyze idea and extract components."""
        components = []
        idea_lower = idea.lower()

        if "database" in idea_lower or "data" in idea_lower:
            components.append("Database layer")
        if "api" in idea_lower or "service" in idea_lower:
            components.append("API service")
        if "authentication" in idea_lower or "login" in idea_lower:
            components.append("Authentication module")
        if "user" in idea_lower:
            components.append("User management")

        if not components:
            components.append("Core module")

        return components

    def _generate_code(self, context: str, node_id: str) -> str:
        """Generate code based on context (placeholder for Multi-IA call)."""
        return f"# Generated code for node {node_id}\n# Context: {len(context)} chars\npass"

    def _create_deployment_config(self, code: str) -> Dict[str, Any]:
        """Create deployment configuration."""
        return {
            "runtime": "python3.11",
            "dependencies": ["fastapi", "uvicorn"],
            "code_size": len(code)
        }

    def save_knowledge_graph(self, path: str) -> None:
        """Save the current knowledge graph to a JSON file."""
        self.knowledge_graph.save_to_json(path)
